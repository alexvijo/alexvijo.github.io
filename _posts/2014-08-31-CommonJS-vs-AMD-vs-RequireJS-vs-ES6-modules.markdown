---
layout: post
title:  "CommonJS vs AMD vs RequireJS vs ES6 Modules"
date:   2014-08-31 15:24:21
tags: [jekyll, update]
---
<div class="section-inner sectionLayout--insetColumn"><h1 name="bacc" id="bacc" class="graf graf--h3 graf--leading graf--title">CommonJS vs AMD vs RequireJS vs ES6 Modules</h1><strong class="markup--strong markup--p-strong">JavaScript Modules</strong> refer to a small units of independent, reusable code. They have distinct functionality, allowing them to be added, removed without disrupting the system. It seems to mimic how classes are used in Java or Python.</p><p name="706d" id="706d" class="graf graf--p graf-after--p">Modules are self-contained. Updating a module is much easier if it is decoupled from other pieces of code. This encourages the programmer to go through the program a lot less intimidating. It solves the namespace ambiguity as well allowing the objects to be created in publicly accessible namespaces while the functions in it remain <strong class="markup--strong markup--p-strong">private</strong>. Modules can be <strong class="markup--strong markup--p-strong">reused,</strong> eliminating duplicate pieces of code thereby saving huge amount of time.<br>Before the modules arrived, The <strong class="markup--strong markup--p-strong">Revealing Module Pattern</strong> was getting used.</p><pre name="7de6" id="7de6" class="graf graf--pre graf-after--p">var revealingModule = (function () {<br>    var privateVar = "Ben Thomas";<br>    function setNameFn( strName ) {<br>        privateVar = strName;<br>    }<br>return {<br>        setName: setNameFn,<br>    };<br>})();</pre><pre name="b764" id="b764" class="graf graf--pre graf-after--pre">revealingModule.setName( "Paul Adams" );</pre><p name="4574" id="4574" class="graf graf--p graf-after--pre">In this program, the public functions are exposed while the private properties and methods are encapsulated.</p><p name="36a0" id="36a0" class="graf graf--p graf-after--p">Multiple modules can be defined in a single file but the downslides are that asynchronous loading of modules is not possible, cannot import modules programmatically.</p><p name="e7ba" id="e7ba" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">CommonJS</strong></p><p name="05d7" id="05d7" class="graf graf--p graf-after--p">They came up with a separate approach to interact with the module system using the keywords <em class="markup--em markup--p-em">require</em> and <em class="markup--em markup--p-em">exports</em>. require is a function used to import functions from another module. exports is an object where any function put into it will get exported.</p><pre name="99da" id="99da" class="graf graf--pre graf-after--p">//------ payments.js ------<br>var customerStore = require('store/customer'); // import module</pre><pre name="597d" id="597d" class="graf graf--pre graf-after--pre">//------ store/customer.js ------<br>exports = function(){<br>    return customers.get('store);<br>}</pre><p name="4b04" id="4b04" class="graf graf--p graf-after--pre">In the above example, the customerStore is imported to the payments.js. The function which is set to the exports object in customer module is loaded in payments file.</p><p name="a5f3" id="a5f3" class="graf graf--p graf-after--p">These modules are designer for server development and these are synchronous.ie., the files are loaded one by one in order inside the file.</p><p name="77a7" id="77a7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">NodeJS implementation</strong></p><p name="3a00" id="3a00" class="graf graf--p graf-after--p">They are heavily influenced by CommonJS specification. The major difference arises in the exports object. NodeJS modules use <em class="markup--em markup--p-em">module.exports </em>as the object to get exported while CommonJS uses just the <em class="markup--em markup--p-em">exports</em> variable.</p><pre name="c495" id="c495" class="graf graf--pre graf-after--p">//payments.js<br>var customerStore = require('store/customer'); // import module</pre><pre name="b09e" id="b09e" class="graf graf--pre graf-after--pre">//store/customer.js<br>function customerStore(){<br>    return customers.get('store);<br>}<br>modules.exports = customerStore;</pre><p name="2bde" id="2bde" class="graf graf--p graf-after--pre">They are also synchronous in nature. The parameter passed to the <em class="markup--em markup--p-em">require</em> checks for the module name inside the <em class="markup--em markup--p-em">node_modules</em> directory. Circular dependencies are supported and a developer can easily understand the concepts. The cons are just one file per module, only objects are made as modules and the browsers cannot use these modules directly without transpiling.</p><p name="3dbf" id="3dbf" class="graf graf--p graf-after--p">But recently Browserify, used to bundle code from the modules uses this method in the browser. Webpack also handles complex pipelines of source transformations which includes CommonJS modules.</p><p name="7d98" id="7d98" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Asynchronous Module Definition (AMD)</strong></p><p name="4008" id="4008" class="graf graf--p graf-after--p">AMD was born as CommonJS wasn’t suited for the browsers early on. As the name implies, it supports asynchronous module loading.</p><pre name="9569" id="9569" class="graf graf--pre graf-after--p">define(['module1', ',module2'], function(module1, module2) {<br>  console.log(module1.setName());<br>});</pre><p name="9d58" id="9d58" class="graf graf--p graf-after--pre">The function is called only when the requested modules are finished loading. The <em class="markup--em markup--p-em">define</em> function takes the first argument as an array of dependency modules. These modules are loaded in a non-blocking manner in the background and once the loading is completed, the callback function is executed.</p><p name="259d" id="259d" class="graf graf--p graf-after--p">It is designed to be used in browsers for better startup times and these modules can be objects, functions, constructors, strings, JSON, etc. Modules can be split in multiple files, which are compatible for <em class="markup--em markup--p-em">require</em> and <em class="markup--em markup--p-em">exports</em> and circular dependencies are supported as well.</p><p name="7347" id="7347" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">RequireJS </strong>implements the AMD API. It loads the plain JavaScript files as well as modules by using plain script tags. It includes an optimizing tool which can be run while deploying our code for better performance.</p><pre name="c1f8" id="c1f8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">&lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;</code></pre><p name="bdec" id="bdec" class="graf graf--p graf-after--pre">This is the only code required to include files in RequireJS. The <em class="markup--em markup--p-em">date-main </em>attribute defines the initialization and it looks for scripts and dependencies.</p><p name="c51d" id="c51d" class="graf graf--p graf-after--p">As you probably noticed, none of the modules above were native to JavaScript. We tried to emulate a module system using the module pattern, CommonJS and AMD. Fortunately, ECMAScript 6 have introduced built-in modules which takes it through to the next and final section.</p><p name="e82e" id="e82e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ECMAScript 6 modules (Native JavaScript)</strong></p><p name="0d93" id="0d93" class="graf graf--p graf-after--p">ECMAScript 6 a.k.a., ES6 a.ka., ES2015 offers possibilities for importing and exporting modules compatible with both synchronous and asynchronous modes of operation.</p><pre name="77a5" id="77a5" class="graf graf--pre graf-after--p">//------ lib.js ------<br>export const sqrt = Math.sqrt;<br>export function square(x) {<br>    return x * x;<br>}<br>export function diag(x, y) {<br>    return sqrt(square(x) + square(y));<br>}</pre><pre name="b9ac" id="b9ac" class="graf graf--pre graf-after--pre">//------ main.js ------</pre><pre name="b4d5" id="b4d5" class="graf graf--pre graf-after--pre">import { square, diag } from 'lib';<br>console.log(square(11)); // 121<br>console.log(diag(4, 3)); // 5</pre><p name="02ae" id="02ae" class="graf graf--p graf-after--pre">The <em class="markup--em markup--p-em">import</em> statement is used to bring modules into the namespace. It is not dynamic, cannot be used anywhere in the file. This is in contrast with the require and define. Th <em class="markup--em markup--p-em">export</em> statement makes the elements public. This static behavior makes the static analyzers build the tree of dependencies while bundling the file without running code. This is used by modern JavaScript frameworks like ReactJS, EmberJS, etc. The drawback is that it isn’t fully implemented in the browsers and it requires a transpiler like Babel to render in the unsupported browsers.</p><p name="5b2d" id="5b2d" class="graf graf--p graf-after--p graf--trailing">If you are looking at starting a new module or project, ES2015 is the right way to go and CommonJS/Node remains the choice for the server.</p></div>
